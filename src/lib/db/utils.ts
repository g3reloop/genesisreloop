import { PrismaClient } from '@prisma/client';
import { cache } from '../redis/client';

// Singleton pattern for Prisma Client
const globalForPrisma = global as unknown as { prisma: PrismaClient };

export const prisma =
  globalForPrisma.prisma ||
  new PrismaClient({
    log: process.env.NODE_ENV === 'development' ? ['query', 'error', 'warn'] : ['error'],
  });

if (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma;

// Common database utilities
export const db = {
  // Get user with role-specific data
  async getUserWithRole(userId: string) {
    const cacheKey = cache.cacheKeys.user(userId);
    const cached = await cache.get(cacheKey);
    if (cached) return cached;

    const user = await prisma.user.findUnique({
      where: { id: userId },
      include: {
        supplier: true,
        processor: true,
        buyer: true,
        collector: true,
        subscriptions: {
          where: { status: 'ACTIVE' },
          orderBy: { createdAt: 'desc' },
          take: 1,
        },
      },
    });

    if (user) {
      await cache.set(cacheKey, user, 300); // Cache for 5 minutes
    }

    return user;
  },

  // Get dashboard statistics
  async getDashboardStats() {
    const cacheKey = 'dashboard:stats';
    const cached = await cache.get(cacheKey);
    if (cached) return cached;

    // Use raw SQL for complex aggregations
    const stats = await prisma.$queryRaw`
      SELECT 
        COUNT(DISTINCT s.id) as total_suppliers,
        COUNT(DISTINCT p.id) as total_processors,
        COUNT(DISTINCT fb.id) as total_batches,
        SUM(fb.quantity) as total_feedstock_kg,
        COUNT(DISTINCT fb.id) FILTER (WHERE fb."loopType" = 'SRL') as srl_batches,
        SUM(cc."co2Avoided") as total_co2_avoided
      FROM "User" u
      LEFT JOIN "Supplier" s ON u.id = s."userId"
      LEFT JOIN "Processor" p ON u.id = p."userId"
      LEFT JOIN "FeedstockBatch" fb ON s.id = fb."supplierId"
      LEFT JOIN "CarbonCredit" cc ON fb."batchCode" = cc."batchCode"
    `;

    await cache.set(cacheKey, stats, 900); // Cache for 15 minutes
    return stats;
  },

  // Get recent activity for user
  async getRecentActivity(userId: string, limit = 10) {
    const activities = await prisma.$transaction([
      // Recent batches
      prisma.feedstockBatch.findMany({
        where: {
          supplier: { userId },
        },
        orderBy: { createdAt: 'desc' },
        take: limit,
        include: {
          collection: true,
          processedBatch: true,
        },
      }),
      // Recent notifications
      prisma.notification.findMany({
        where: { userId },
        orderBy: { createdAt: 'desc' },
        take: limit,
      }),
    ]);

    return {
      batches: activities[0],
      notifications: activities[1],
    };
  },

  // Batch operations with transaction
  async createBatchWithCollection(data: {
    supplierId: string;
    feedstockType: 'UCO' | 'FOOD_WASTE' | 'MIXED';
    quantity: number;
    fatContent?: number;
    temperature?: number;
  }) {
    return await prisma.$transaction(async (tx) => {
      // Create batch
      const batch = await tx.feedstockBatch.create({
        data: {
          ...data,
          batchCode: '', // Will be auto-generated by trigger
          loopType: 'UNKNOWN',
          status: 'REGISTERED',
        },
      });

      // Log agent activity
      await tx.agentActivity.create({
        data: {
          agentName: 'System',
          action: 'create_batch',
          inputData: data,
          outputData: { batchId: batch.id },
          success: true,
          duration: 0,
        },
      });

      return batch;
    });
  },

  // Update batch quality with verification
  async updateBatchQuality(
    batchId: string,
    qualityData: {
      fatContent: number;
      temperature: number;
      qualityScore: number;
      loopType: 'SRL' | 'CRL';
    }
  ) {
    return await prisma.$transaction(async (tx) => {
      // Update batch
      const batch = await tx.feedstockBatch.update({
        where: { id: batchId },
        data: qualityData,
      });

      // Create trace data
      await tx.traceData.create({
        data: {
          batchId,
          location: 'Quality Check Point',
          temperature: qualityData.temperature,
          fatContent: qualityData.fatContent,
          verified: true,
        },
      });

      // Clear cache
      await cache.del(cache.cacheKeys.batch(batchId));

      return batch;
    });
  },

  // Process batch and create carbon credits
  async processBatch(
    batchId: string,
    processorId: string,
    processData: {
      primaryOutput: number;
      byproducts: Record<string, number>;
    }
  ) {
    return await prisma.$transaction(async (tx) => {
      // Create processed batch record
      const processed = await tx.processedBatch.create({
        data: {
          batchId,
          processorId,
          primaryOutput: processData.primaryOutput,
          byproducts: processData.byproducts,
          carbonCredits: 0, // Will be calculated by trigger
        },
      });

      // Update batch status
      await tx.feedstockBatch.update({
        where: { id: batchId },
        data: { status: 'PROCESSED' },
      });

      // Carbon credits will be created by database trigger

      return processed;
    });
  },

  // Search and filter batches
  async searchBatches(filters: {
    status?: string;
    feedstockType?: string;
    loopType?: string;
    supplierId?: string;
    dateFrom?: Date;
    dateTo?: Date;
    minQuantity?: number;
    maxQuantity?: number;
  }) {
    const where: any = {};

    if (filters.status) where.status = filters.status;
    if (filters.feedstockType) where.feedstockType = filters.feedstockType;
    if (filters.loopType) where.loopType = filters.loopType;
    if (filters.supplierId) where.supplierId = filters.supplierId;
    
    if (filters.dateFrom || filters.dateTo) {
      where.createdAt = {};
      if (filters.dateFrom) where.createdAt.gte = filters.dateFrom;
      if (filters.dateTo) where.createdAt.lte = filters.dateTo;
    }

    if (filters.minQuantity || filters.maxQuantity) {
      where.quantity = {};
      if (filters.minQuantity) where.quantity.gte = filters.minQuantity;
      if (filters.maxQuantity) where.quantity.lte = filters.maxQuantity;
    }

    return await prisma.feedstockBatch.findMany({
      where,
      include: {
        supplier: true,
        collection: true,
        processedBatch: true,
      },
      orderBy: { createdAt: 'desc' },
    });
  },

  // Analytics queries
  async getSupplierAnalytics(supplierId: string, days = 30) {
    const startDate = new Date();
    startDate.setDate(startDate.getDate() - days);

    const [batches, reputation, carbonCredits] = await prisma.$transaction([
      // Batch statistics
      prisma.feedstockBatch.groupBy({
        by: ['status', 'loopType'],
        where: {
          supplierId,
          createdAt: { gte: startDate },
        },
        _count: true,
        _sum: {
          quantity: true,
        },
      }),
      // Reputation scores
      prisma.reputationScore.findMany({
        where: {
          supplierId,
          createdAt: { gte: startDate },
        },
        orderBy: { createdAt: 'asc' },
      }),
      // Carbon credits earned
      prisma.$queryRaw`
        SELECT 
          SUM(cc."co2Avoided") as total_co2,
          COUNT(cc.id) as credit_count
        FROM "CarbonCredit" cc
        JOIN "FeedstockBatch" fb ON cc."batchCode" = fb."batchCode"
        WHERE fb."supplierId" = ${supplierId}
        AND cc."createdAt" >= ${startDate}
      `,
    ]);

    return {
      batches,
      reputation,
      carbonCredits,
    };
  },
};
